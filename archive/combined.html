<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Ghost City v60 (Ramps & Interchanges)</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    
    <script src="https://unpkg.com/maplibre-gl@3.6.0/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@3.6.0/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.3/mapbox-gl-draw.js"></script>
    <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.3/mapbox-gl-draw.css" type="text/css" />
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

    <style>
        body { margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; height: 100vh; overflow: hidden;}
        
        #sidebar {
            width: 250px; background: #2c3e50; color: white; padding: 20px;
            display: flex; flex-direction: column; gap: 12px; z-index: 2000;
            box-shadow: 2px 0 5px rgba(0,0,0,0.2);
        }

        /* Map Background: Google Light Grey */
        #map { flex-grow: 1; position: relative; background-color: #f0f0f0; }
        
        /* HELP PANEL */
        #help-panel {
            position: absolute; top: 0; right: 0; bottom: 0; width: 350px;
            background: white; z-index: 3000;
            box-shadow: -2px 0 5px rgba(0,0,0,0.1);
            padding: 30px; overflow-y: auto;
            transform: translateX(100%); transition: transform 0.3s ease-in-out;
            line-height: 1.6; color: #333;
        }
        #help-panel.open { transform: translateX(0); }
        .close-btn { background: none; border: none; font-size: 20px; cursor: pointer; position: absolute; top: 15px; right: 15px; color: #999;}

        /* CONTEXT MENUS */
        .context-menu {
            display: none; background: rgba(0,0,0,0.2); padding: 10px;
            border-radius: 6px; margin-top: 5px; text-align: center;
        }
        .control-row { display: flex; justify-content: center; gap: 5px; margin-bottom: 8px; }
        .btn-mini { width: 30px; height: 30px; padding: 0; justify-content: center; background: #34495e; font-size: 16px; border: 1px solid #555; cursor:pointer; color:white; border-radius:4px;}
        .btn-mini:hover { background: #4e6a85; }
        .btn-wide { width: 100%; font-size: 12px; padding: 8px; }

        button { padding: 12px; border: none; border-radius: 6px; font-size: 14px; cursor: pointer; font-weight: bold; display: flex; align-items: center; gap: 10px; transition: transform 0.1s; }
        button:active { transform: scale(0.98); }
        
        .btn-select { background-color: #34495e; color: white; border: 1px solid #4a6278; }
        .btn-undo { background-color: #f1c40f; color: #333; }
        .btn-label { background-color: #9b59b6; color: white; }
        .btn-delete { background-color: #e74c3c; color: white; margin-top: 10px; }
        .btn-delete.point-mode { background-color: #8e44ad; } 
        .btn-save { background-color: #27ae60; color: white; margin-top: auto;}
        .btn-load { background-color: #3498db; color: white; }
        .btn-help { background-color: #95a5a6; color: white; margin-top: 10px; }
        
        /* ROAD TYPES */
        .btn-freeway { background-color: #7a8ea3; color: white; } /* Slate */
        .btn-ramp { background-color: #aebdc9; color: #333; }     /* Light Slate */
        .btn-major { background-color: #ecf0f1; color: #333; }    /* White */
        .btn-minor { background-color: #bdc3c7; color: #333; }    /* Grey */
        
        .btn-curve { background-color: #27ae60; color: white; width:100%; }
        .btn-straight { background-color: #e67e22; color: white; width:100%; }

        .toggle-container { display: flex; align-items: center; gap: 10px; background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px; margin-top: 10px; }
        #debug-info { margin-top: 10px; font-size: 11px; color: #7f8c8d; text-align: center;}
    </style>
</head>
<body>

<div id="sidebar">
    <h2 style="margin:0; color:white;">Ghost City</h2>
    <p style="color:#bdc3c7; font-size:12px; margin-bottom:15px;">v60: Ramps</p>
    
    <button class="btn-undo" onclick="undo()"><span>‚Ü©Ô∏è</span> Undo</button>
    <div style="height:10px;"></div>

    <button class="btn-select" onclick="enterSelectMode()"><span>üëÜ</span> Select / Edit</button>
    <button class="btn-label" onclick="activateLabelTool()"><span>üìç</span> Place Label</button>

    <div id="road-controls" class="context-menu">
        <div class="control-label">Road Options</div>
        <button id="btn-curve-toggle" class="btn-mini btn-wide btn-curve" onclick="toggleLineSmoothing()">„Ä∞Ô∏è Make Smooth</button>
    </div>

    <div id="text-controls" class="context-menu">
        <div class="control-label">Move</div>
        <div class="control-row">
            <button class="btn-mini" onclick="nudgeLabel(0, -5)">‚¨ÜÔ∏è</button>
        </div>
        <div class="control-row">
            <button class="btn-mini" onclick="nudgeLabel(-5, 0)">‚¨ÖÔ∏è</button>
            <button class="btn-mini" onclick="nudgeLabel(0, 5)">‚¨áÔ∏è</button>
            <button class="btn-mini" onclick="nudgeLabel(5, 0)">‚û°Ô∏è</button>
        </div>
        <div class="control-label">Rotate</div>
        <div class="control-row">
            <button class="btn-mini" onclick="rotateLabel(-5)">‚Ü∫</button>
            <button class="btn-mini" onclick="rotateLabel(5)">‚Üª</button>
        </div>
        <div class="control-row">
            <button class="btn-mini btn-wide" onclick="editLabelText()">‚úé Edit Text</button>
        </div>
    </div>

    <div style="height:10px;"></div>
    
    <button class="btn-freeway" onclick="startDrawing('freeway')"><span>üõ£Ô∏è</span> Freeway</button>
    <button class="btn-ramp" onclick="startDrawing('ramp')"><span>‚§¥Ô∏è</span> Ramp</button>
    <button class="btn-major" onclick="startDrawing('major')"><span>üèôÔ∏è</span> Major Road</button>
    <button class="btn-minor" onclick="startDrawing('minor')"><span>üèòÔ∏è</span> Minor Street</button>
    
    <div class="toggle-container">
        <input type="checkbox" id="smooth-toggle" style="width:20px; height:20px;" checked>
        <label for="smooth-toggle">New: Auto-Smooth</label>
    </div>

    <button id="btn-delete" class="btn-delete" onclick="smartDelete()"><span>üóëÔ∏è</span> Delete Selected</button>
    <button class="btn-help" onclick="toggleHelp()"><span>‚ùì</span> Open User Guide</button>
    
    <div id="debug-info">Points: 0</div>
    <div style="flex-grow:1;"></div>

    <button class="btn-save" onclick="downloadMap()">üíæ Save Map</button>
    <button class="btn-load" onclick="document.getElementById('file-input').click()">üìÇ Load Map</button>
    <input type="file" id="file-input" style="display:none" onchange="loadMap(this)" accept=".geojson,.json" />
</div>

<div id="help-panel">
    <button class="close-btn" onclick="toggleHelp()">‚úñ</button>
    <h2 style="color:#333;">User Guide</h2>
    <h4>Road Hierarchy</h4>
    <ul>
        <li><strong>Freeway:</strong> Top level. Thickest.</li>
        <li><strong>Ramp:</strong> Connects Freeways to streets. Thinner, same color.</li>
        <li><strong>Major:</strong> Wide white arterial roads.</li>
        <li><strong>Minor:</strong> Thin neighborhood streets.</li>
    </ul>
</div>

<div id="map"></div>

<script>
    let currentRoadType = 'major'; 
    let isLabelMode = false;
    let smoothMap = {}; 
    let historyStack = [];
    let historyStep = -1;

    // --- UNDO ---
    function saveState() {
        if (historyStep < historyStack.length - 1) historyStack = historyStack.slice(0, historyStep + 1);
        historyStack.push(JSON.stringify(draw.getAll()));
        historyStep++;
        if (historyStack.length > 20) { historyStack.shift(); historyStep--; }
    }
    function undo() {
        if (historyStep > 0) {
            historyStep--;
            draw.set(JSON.parse(historyStack[historyStep]));
            updateVisuals();
        }
    }

    var map = new maplibregl.Map({
        container: 'map', center: [0, 0], zoom: 14,
        style: {
            "version": 8, "name": "GoogleStyle", 
            "glyphs": "https://protomaps.github.io/basemaps-assets/fonts/{fontstack}/{range}.pbf",
            "sources": {},
            "layers": [{ "id": "background", "type": "background", "paint": { "background-color": "#f0f0f0" } }]
        }
    });

    var nav = new maplibregl.NavigationControl({ showCompass: true, visualizePitch: true });
    map.addControl(nav, 'top-right');

    const drawStyles = [
        { "id": "gl-draw-polygon-and-line-midpoint", "type": "circle", "filter": ["all", ["==", "$type", "Point"], ["==", "meta", "midpoint"]], "paint": { "circle-radius": 4, "circle-color": "#3498db" } },
        { "id": "gl-draw-vertex-inactive", "type": "circle", "filter": ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "active", "true"]], "paint": { "circle-radius": 5, "circle-color": "#fff", "circle-stroke-width": 1, "circle-stroke-color": "#000" } },
        { "id": "gl-draw-vertex-active", "type": "circle", "filter": ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["==", "active", "true"]], "paint": { "circle-radius": 7, "circle-color": "#e74c3c" } },
        { "id": "gl-draw-line-active", "type": "line", "filter": ["all", ["==", "$type", "LineString"], ["==", "active", "true"]], "paint": { "line-color": "#ff0000", "line-width": 2, "line-dasharray": [2, 2] } },
        { "id": "gl-draw-line-inactive", "type": "line", "filter": ["all", ["==", "$type", "LineString"], ["!=", "active", "true"]], "paint": { "line-color": "#000", "line-width": 15, "line-opacity": 0 } },
        { "id": "gl-draw-point-anchor", "type": "circle", "filter": ["all", ["==", "$type", "Point"], ["==", "user_isLabel", true], ["==", "active", "true"]], "paint": { "circle-radius": 6, "circle-color": "#9b59b6", "circle-stroke-width": 2, "circle-stroke-color": "#fff" } },
        { "id": "gl-draw-point-text", "type": "symbol", "filter": ["all", ["==", "$type", "Point"], ["==", "user_isLabel", true]], "layout": { "text-field": ["get", "user_name"], "text-font": ["Noto Sans Regular"], "text-size": 12, "text-rotate": ["coalesce", ["get", "user_rotation"], 0], "text-offset": ["coalesce", ["get", "user_offset"], ["literal", [0, -1.5]]], "text-anchor": "center", "text-ignore-placement": true, "text-allow-overlap": true }, "paint": { "text-color": "#333", "text-halo-color": "#fff", "text-halo-width": 2 } }
    ];

    var draw = new MapboxDraw({ displayControlsDefault: false, userProperties: true, styles: drawStyles });
    
    // --- LOAD LAYERS ---
    map.on('load', function() {
        map.addControl(draw);
        var layers = map.getStyle().layers;
        var firstDrawLayerId;
        for (var i = 0; i < layers.length; i++) { if (layers[i].id.indexOf('gl-draw') === 0) { firstDrawLayerId = layers[i].id; break; } }

        map.addSource('smooth_source', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });

        // --- Z-INDEX STACK (Bottom to Top) ---
        
        // 1. Minor
        map.addLayer({ "id": "visual-minor-border", "type": "line", "source": "smooth_source", "filter": ["==", "roadType", "minor"], "paint": { "line-color": "#d6d6d6", "line-width": 6 } }, firstDrawLayerId);
        map.addLayer({ "id": "visual-minor-fill", "type": "line", "source": "smooth_source", "filter": ["==", "roadType", "minor"], "paint": { "line-color": "#ffffff", "line-width": 3 } }, firstDrawLayerId);

        // 2. Major
        map.addLayer({ "id": "visual-major-border", "type": "line", "source": "smooth_source", "filter": ["==", "roadType", "major"], "paint": { "line-color": "#cfcfcf", "line-width": 12 } }, firstDrawLayerId);
        map.addLayer({ "id": "visual-major-fill", "type": "line", "source": "smooth_source", "filter": ["==", "roadType", "major"], "paint": { "line-color": "#ffffff", "line-width": 8 } }, firstDrawLayerId);

        // 3. Ramps (NEW) - Sits between Major and Freeway
        map.addLayer({ "id": "visual-ramp-border", "type": "line", "source": "smooth_source", "filter": ["==", "roadType", "ramp"], "paint": { "line-color": "#687d99", "line-width": 8 } }, firstDrawLayerId);
        map.addLayer({ "id": "visual-ramp-fill", "type": "line", "source": "smooth_source", "filter": ["==", "roadType", "ramp"], "paint": { "line-color": "#ffffff", "line-width": 4 } }, firstDrawLayerId);

        // 4. Freeways
        map.addLayer({ "id": "visual-freeway-border", "type": "line", "source": "smooth_source", "filter": ["==", "roadType", "freeway"], "paint": { "line-color": "#687d99", "line-width": 18 } }, firstDrawLayerId);
        map.addLayer({ "id": "visual-freeway-fill", "type": "line", "source": "smooth_source", "filter": ["==", "roadType", "freeway"], "paint": { "line-color": "#90a4c2", "line-width": 14 } }, firstDrawLayerId);
        
        saveState();
    });

    map.on('mousemove', function(e) {
        if (draw.getMode() === 'draw_line_string') map.getCanvas().style.cursor = 'crosshair'; 
        else if (draw.getFeatureIdsAt(e.point).length > 0) map.getCanvas().style.cursor = 'pointer'; 
        else map.getCanvas().style.cursor = ''; 
    });

    // --- HELPER FUNCTIONS ---
    function toggleHelp() { document.getElementById('help-panel').classList.toggle('open'); }
    function enterSelectMode() { draw.changeMode('simple_select'); }
    function startDrawing(type) { isLabelMode = false; currentRoadType = type; draw.changeMode('draw_line_string'); }
    function activateLabelTool() { isLabelMode = true; draw.changeMode('draw_point'); }

    // --- SELECTION LOGIC ---
    map.on('draw.selectionchange', function(e) {
        var btnDelete = document.getElementById('btn-delete');
        var selectedPoints = draw.getSelectedPoints();
        
        if (selectedPoints.features.length > 0) {
            btnDelete.innerHTML = "<span>üìç</span> Delete Point"; btnDelete.classList.add('point-mode');
        } else if (e.features.length > 0) {
            btnDelete.innerHTML = "<span>üóëÔ∏è</span> Delete Road"; btnDelete.classList.remove('point-mode');
        } else {
            btnDelete.innerHTML = "<span>üóëÔ∏è</span> Delete Selected"; btnDelete.classList.remove('point-mode');
        }

        if (e.features.length > 0) {
            var f = e.features[0];
            if (f.geometry.type === 'LineString') {
                document.getElementById('debug-info').innerText = "Points: " + f.geometry.coordinates.length;
                showTextControls(false);
                showRoadControls(true, f); 
                var featureId = f.id;
                setTimeout(() => { if(draw.getMode() === 'simple_select') draw.changeMode('direct_select', { featureId: featureId }); }, 50);
            } 
            else if (f.geometry.type === 'Point' && f.properties.isLabel) {
                showTextControls(true); showRoadControls(false);
            }
        } else {
            showTextControls(false); showRoadControls(false); document.getElementById('debug-info').innerText = "Points: 0";
        }
    });

    function showTextControls(show) { document.getElementById('text-controls').style.display = show ? 'block' : 'none'; }
    function showRoadControls(show, feature) { 
        var panel = document.getElementById('road-controls');
        panel.style.display = show ? 'block' : 'none';
        if (show && feature) {
            var btn = document.getElementById('btn-curve-toggle');
            var isSmoothed = feature.properties.isSmoothed !== false; 
            if (isSmoothed) { btn.className = "btn-mini btn-wide btn-straight"; btn.innerHTML = "üìè Make Straight"; } 
            else { btn.className = "btn-mini btn-wide btn-curve"; btn.innerHTML = "„Ä∞Ô∏è Make Smooth"; }
        }
    }

    function toggleLineSmoothing() { var ids = draw.getSelectedIds(); if (ids.length) { var f = draw.get(ids[0]); draw.setFeatureProperty(ids[0], 'isSmoothed', !(f.properties.isSmoothed !== false)); showRoadControls(true, draw.get(ids[0])); updateVisuals(); saveState(); } }
    function rotateLabel(deg) { var ids = draw.getSelectedIds(); if (ids.length) { var f = draw.get(ids[0]); draw.setFeatureProperty(ids[0], 'rotation', (f.properties.rotation || 0) + deg); saveState(); } }
    function nudgeLabel(dx, dy) { var ids = draw.getSelectedIds(); if (ids.length) { var f = draw.get(ids[0]); var o = f.properties.offset || [0, -1.5]; draw.setFeatureProperty(ids[0], 'offset', [o[0] + dx/10, o[1] + dy/10]); saveState(); } }
    function editLabelText() { var ids = draw.getSelectedIds(); if (ids.length) { var f = draw.get(ids[0]); var n = prompt("Edit label:", f.properties.name); if(n) { draw.setFeatureProperty(ids[0], 'name', n); saveState(); } } }

    map.on('draw.create', function(e) {
        var f = e.features[0];
        if (f.geometry.type === 'Point' && isLabelMode) {
            var name = prompt("Enter label text:", "Street Name");
            if (name) {
                draw.setFeatureProperty(f.id, 'isLabel', true);
                draw.setFeatureProperty(f.id, 'name', name);
                draw.setFeatureProperty(f.id, 'rotation', 0);
                draw.setFeatureProperty(f.id, 'offset', [0, -1.5]);
                
                var pt = f.geometry.coordinates;
                var linkedId = null;
                var linkedRatio = 0;
                Object.keys(smoothMap).forEach(roadId => {
                    var line = smoothMap[roadId];
                    if (line) {
                        var snapped = turf.nearestPointOnLine(line, pt);
                        if (snapped.properties.dist < 0.05) { 
                            linkedId = roadId;
                            var len = turf.length(line);
                            linkedRatio = snapped.properties.location / len;
                        }
                    }
                });
                if (linkedId) { draw.setFeatureProperty(f.id, 'linkedRoadId', linkedId); draw.setFeatureProperty(f.id, 'linkedRatio', linkedRatio); }
                saveState();
            } else { draw.delete(f.id); }
            isLabelMode = false;
        } else if (f.geometry.type === 'LineString') {
            draw.setFeatureProperty(f.id, 'roadType', currentRoadType);
            var autoSmooth = document.getElementById('smooth-toggle').checked;
            draw.setFeatureProperty(f.id, 'isSmoothed', autoSmooth);
            setTimeout(() => { updateVisuals(); saveState(); }, 10);
        }
    });

    map.on('draw.update', function(e) {
        updateVisuals(); 
        if (e.features.length > 0 && e.features[0].geometry.type === 'LineString') {
            var roadId = e.features[0].id;
            setTimeout(() => {
                var smoothLine = smoothMap[roadId];
                if (!smoothLine) return;
                var allLabels = draw.getAll().features.filter(f => f.properties.linkedRoadId === roadId);
                allLabels.forEach(lbl => {
                    var ratio = lbl.properties.linkedRatio;
                    if (ratio >= 0 && ratio <= 1) {
                        var len = turf.length(smoothLine);
                        var newPos = turf.along(smoothLine, len * ratio);
                        draw.add({ id: lbl.id, type: 'Feature', properties: lbl.properties, geometry: newPos.geometry });
                    }
                });
            }, 20);
        }
    });
    
    map.on('mouseup', function() { if (draw.getMode() === 'direct_select' || draw.getMode() === 'simple_select') saveState(); });
    map.on('draw.delete', function(){ updateVisuals(); saveState(); });

    function updateVisuals() {
        var rawData = draw.getAll();
        var smoothFeatures = [];
        smoothMap = {};

        rawData.features.forEach(f => {
            if (f.geometry.type === 'LineString') {
                var rType = f.properties.roadType || currentRoadType; 
                var isSmoothed = f.properties.isSmoothed !== false; 
                var displayFeat = JSON.parse(JSON.stringify(f));
                displayFeat.properties.roadType = rType; 

                if (isSmoothed && f.geometry.coordinates.length > 2) {
                    try {
                        var clean = turf.cleanCoords(displayFeat); 
                        var curved = turf.bezierSpline(clean, { resolution: 10000, sharpness: 0.85 });
                        curved.properties = displayFeat.properties; 
                        smoothFeatures.push(curved);
                        smoothMap[f.id] = curved; 
                    } catch(err) {
                        smoothFeatures.push(displayFeat);
                        smoothMap[f.id] = displayFeat;
                    }
                } else {
                    smoothFeatures.push(displayFeat);
                    smoothMap[f.id] = displayFeat;
                }
            }
        });
        
        var source = map.getSource('smooth_source');
        if (source) source.setData({ type: 'FeatureCollection', features: smoothFeatures });
    }

    function smartDelete() {
        var pts = draw.getSelectedPoints();
        if (pts.features.length > 0) draw.trash();
        else { var ids = draw.getSelectedIds(); if (ids.length > 0) draw.delete(ids); else draw.trash(); }
    }
    document.addEventListener('keydown', function(e) { 
        if ((e.ctrlKey || e.metaKey) && e.key === 'z') { undo(); return; }
        if (e.key === 'Delete' || e.key === 'Backspace') smartDelete(); 
    });

    function downloadMap() {
        var data = draw.getAll();
        if (data.features.length === 0) { alert("Map is empty!"); return; }
        var blob = new Blob([JSON.stringify(data)], {type: "application/geo+json"});
        var a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = "ghost-city.geojson";
        a.click();
    }
    function loadMap(input) {
        var file = input.files[0];
        if (!file) return;
        var reader = new FileReader();
        reader.onload = function(e) {
            try {
                var json = JSON.parse(e.target.result);
                draw.deleteAll(); draw.add(json);
                updateVisuals(); 
                saveState();
                var bounds = new maplibregl.LngLatBounds();
                json.features.forEach(f => { if(f.geometry.type === 'Point') bounds.extend(f.geometry.coordinates); else f.geometry.coordinates.forEach(c => bounds.extend(c)); });
                if (!bounds.isEmpty()) map.fitBounds(bounds, { padding: 50 });
            } catch (error) { alert("Error: " + error); }
        };
        reader.readAsText(file);
        input.value = '';
    }
</script>
</body>
</html>